"""
Merge per-version dropdown lists (2K22â€“2K24, plus 2K26) into a single normalized file.

Inputs (generated by extract_dropdowns.py or extracted_offsets tooling):
    dropdowns_2K22.json
    dropdowns_2K23.json
    dropdowns_2K24.json
    2k26_dropdown_values.json (category -> field map format)

Output:
    mega_dropdowns.json  (in this directory)

Each merged entry keeps a canonical category/name pair and a versions map:
{
  "canonical_category": "...",
  "normalized_name": "...",
  "display_name": "...",
  "versions": {
      "2K22": {"type": "...", "dropdown": [...], "values": [...]},
      "2K23": {...},
      ...
  }
}
"""

from __future__ import annotations

import json
import re
from collections import OrderedDict, defaultdict
from pathlib import Path
from typing import Any, Dict, List, Tuple

ROOT = Path(__file__).resolve().parent
OUTPUT_JSON = ROOT / "mega_dropdowns.json"

VERSION_FILES: "OrderedDict[str, Path]" = OrderedDict(
    [
        ("2K22", ROOT / "dropdowns_2K22.json"),
        ("2K23", ROOT / "dropdowns_2K23.json"),
        ("2K24", ROOT / "dropdowns_2K24.json"),
        # 2K26 file is produced by the 2k26 extraction tooling and ships as a
        # category->field map instead of a flat list; we normalize it in
        # load_version.
        ("2K26", ROOT / "2k26_dropdown_values.json"),
    ]
)


def normalize_name(name: str) -> str:
    """Normalize a field name to a stable dedupe key (aligned with offsets)."""

    def replace_word_numbers(text: str) -> str:
        text = re.sub(r"[_-]+", " ", text)
        word_to_num = {
            "ZERO": "0",
            "ONE": "1",
            "TWO": "2",
            "THREE": "3",
            "FOUR": "4",
            "FIVE": "5",
            "SIX": "6",
            "SEVEN": "7",
            "EIGHT": "8",
            "NINE": "9",
            "TEN": "10",
            "ELEVEN": "11",
            "TWELVE": "12",
            "THIRTEEN": "13",
            "FOURTEEN": "14",
            "FIFTEEN": "15",
            "SIXTEEN": "16",
            "SEVENTEEN": "17",
            "EIGHTEEN": "18",
            "NINETEEN": "19",
            "TWENTY": "20",
            "THIRTY": "30",
            "FORTY": "40",
            "FIFTY": "50",
            "SIXTY": "60",
            "SEVENTY": "70",
            "EIGHTY": "80",
            "NINETY": "90",
            "HUNDRED": "100",
        }
        pattern = re.compile(r"\b(" + "|".join(word_to_num.keys()) + r")\b")
        return pattern.sub(lambda m: word_to_num[m.group(1)], text)

    upper = replace_word_numbers(name.upper())
    fused_rewrites = [
        (r"MIDRANGE", "MID RANGE"),
        (r"CLOSESHOT", "CLOSE SHOT"),
        (r"SHOTCLOSE", "CLOSE SHOT"),
        (r"FREETHROWS", "FREE THROW"),
        (r"FREETHROW", "FREE THROW"),
        (r"3[_\s]*POINT[_\s]*SHOT", "3 POINT"),
        (r"3POINTPOINT", "3 POINT"),
        (r"MID[_\s]*RANGE[_\s]*SHOT", "MID RANGE"),
        (r"MIDRANGESHOT", "MID RANGE"),
        (r"MISC(?:ELLANEOUS|ANELL?OUS)?[_\s]*DURABILITY", "MISC DURABILITY"),
        (r"POST[_\s]*FADE[_\s]*AWAY", "POST FADE"),
        (r"POSTFADEAWAY", "POST FADE"),
        (r"POSTFADE", "POST FADE"),
        (r"TRANSISTION", "TRANSITION"),
        (r"PULLUP", "PULL UP"),
        (r"STEPTHROUGH", "STEP THROUGH"),
    ]
    for pattern, repl in fused_rewrites:
        upper = re.sub(pattern, repl, upper)

    tokens = re.split(r"[^A-Z0-9]+", upper)
    tokens = [t for t in tokens if t]
    return "".join(tokens)


def load_version(version: str, path: Path) -> List[Dict[str, Any]]:
    if not path.exists():
        return []
    data = json.loads(path.read_text(encoding="utf-8"))
    if isinstance(data, list):
        return [d for d in data if isinstance(d, dict)]
    if isinstance(data, dict):
        dropdown_map = data.get("dropdowns") if isinstance(data.get("dropdowns"), dict) else None
        if dropdown_map:
            return flatten_dropdown_map(dropdown_map)
    return []


def flatten_dropdown_map(dropdowns: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Flatten the 2K26 category->field map into the legacy list format."""

    rows: List[Dict[str, Any]] = []

    for category, fields in dropdowns.items():
        if not isinstance(fields, dict):
            continue
        for name, info in fields.items():
            if not isinstance(info, dict):
                continue

            values = None
            dropdown_ref = None

            raw_values = info.get("values")
            if isinstance(raw_values, list):
                values = raw_values
            elif isinstance(raw_values, dict):
                # Preserve numeric order when keys are numeric strings; fall back to insertion order.
                try:
                    items = sorted(raw_values.items(), key=lambda kv: int(kv[0]))
                except Exception:
                    items = raw_values.items()

                values = []
                for _, val in items:
                    if isinstance(val, dict):
                        if "en" in val:
                            values.append(val["en"])
                        elif "value" in val:
                            values.append(val["value"])
                        else:
                            values.append(str(val))
                    else:
                        values.append(val)
            elif raw_values is not None:
                values = [raw_values]

            ref = info.get("ref")
            if values is None:
                if isinstance(ref, (list, tuple)):
                    values = list(ref)
                elif isinstance(ref, str):
                    dropdown_ref = ref

            source = info.get("source")
            # Keep legacy "combo" for static lists; preserve non-static markers like dynamic_dropdown.
            type_value = "combo" if source in {None, "dropdown", "options", "dropdown_values", "value_mapping"} else source

            row = {
                "category": str(category),
                "name": str(name),
            }

            for key, val in (
                ("type", type_value),
                ("dropdown", dropdown_ref),
                ("values", values),
            ):
                if val is not None:
                    row[key] = val

            rows.append(row)

    return rows


def main() -> None:
    entries: Dict[Tuple[str, str], Dict[str, Any]] = {}

    for version, path in VERSION_FILES.items():
        rows = load_version(version, path)
        for row in rows:
            cat = row.get("category")
            name = row.get("name")
            if not isinstance(cat, str) or not isinstance(name, str):
                continue
            key = (cat.strip(), normalize_name(name))
            if key not in entries:
                entries[key] = {
                    "canonical_category": cat.strip(),
                    "normalized_name": key[1],
                    "display_name": name,
                    "versions": {},
                }
            # store per-version data (keep original type/dropdown/values)
            entries[key]["versions"][version] = {
                k: v
                for k, v in row.items()
                if k in {"type", "dropdown", "values"} and v is not None
            }

    mega = {
        "versions": list(VERSION_FILES.keys()),
        "dropdowns": sorted(
            entries.values(),
            key=lambda e: (e["canonical_category"], e["normalized_name"]),
        ),
    }

    OUTPUT_JSON.write_text(json.dumps(mega, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"Merged {len(entries)} dropdown fields into {OUTPUT_JSON}")


if __name__ == "__main__":
    main()
